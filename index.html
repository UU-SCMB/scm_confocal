<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scm_confocal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>scm_confocal</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scm_confocal.util" href="util.html">scm_confocal.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scm_confocal.sp8_image"><code class="flex name class">
<span>class <span class="ident">sp8_image</span></span>
<span>(</span><span>filename, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclass of <code><a title="scm_confocal.sp8_lif" href="#scm_confocal.sp8_lif">sp8_lif</a></code> for relevant attributes and functions for a specific
image in the .lif file. Should not be called directly, but rather be
obtained through <code><a title="scm_confocal.sp8_lif.get_image" href="#scm_confocal.sp8_lif.get_image">sp8_lif.get_image()</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file name of the parent .lif file</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>int</code></dt>
<dd>index number of the image in the parent .lif file</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>int</code></dt>
<dd>index number of the image in the parent .lif file</dd>
<dt><strong><code>lifimage</code></strong> :&ensp;<code>readlif.LifImage class instance</code></dt>
<dd>The underlying class instance of the readlif library.</dd>
</dl>
<p>Additionally, attributes and functions of the parent <code><a title="scm_confocal.sp8_lif" href="#scm_confocal.sp8_lif">sp8_lif</a></code> instance are
inherited and directly accessible, as well as all attributes of the
<code>readlif.LifImage</code> instance.</p>
<p>inherit all functions and attributes from parent sp8_lif class and
add some image specific ones</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scm_confocal.sp8.sp8_lif</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.sp8_image.export_with_scalebar"><code class="name flex">
<span>def <span class="ident">export_with_scalebar</span></span>(<span>self, frame=0, channel=0, filename=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>saves an exported image of the confocal slice with a scalebar in one of
the four corners, where barsize is the scalebar size in data units
(e.g. µm) and scale the overall size of the scalebar and text with
respect to the width of the image. Additionally, a colormap is applied
to the data for better visualisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>index of the frame to export. The default is 0.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code> or <code>list</code> of <code>int</code>, optional</dt>
<dd>the channel to pull the image data from. For displaying multiple
channels in a single image, a list of channel indices can be given,
as well as a list of colormaps for each channel through the <code>cmap</code>
parameter. The default is <code>0</code>.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code>, optional</dt>
<dd>Filename + extension to use for the export file. The default is the
filename sans extension of the original .lif file, with
image name and '_exported.png' appended.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>
<p>range describing a area of the original image (before rescaling the
resolution) to crop out for the export image. Can have two forms:</p>
<ul>
<li>
<p><code>((xmin,ymin),(xmax,ymax))</code>, with the integer indices of the top
left and bottom right corners respectively.</p>
</li>
<li>
<p><code>(xmin,ymin,w,h)</code> with the integer indices of the top left corner
and the width and heigth of the cropped image in pixels (prior to
optional rescaling using <code>resolution</code>).</p>
</li>
</ul>
<p>The default is <code>None</code> which takes the entire image.</p>
</dd>
<dt><strong><code>crop_unit</code></strong> :&ensp;<code>'pixels'</code> or <code>'data'</code>, optional</dt>
<dd>sets the unit in which the width and height in <code>crop</code> are
specified when using the (x,y,w,h) format, with <code>'pixels'</code> to give
the size in pixels or <code>'data'</code> to specify the size in the physical
unit used for the scalebar (after optional unit conversion via the
<code>convert</code> parameter). Note that the position of the top left corner
is given in pixels. The <code>((xmin,ymin),(xmax,ymax))</code> format must be
always given in pixels, and <code>crop_unit</code> is ignored if <code>crop</code> is
given in this format. The default is <code>'pixels'</code>.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the resolution along the x-axis (i.e. image width in pixels) to use
for the exported image. The default is <code>None</code>, which uses the size
of the original image (after optional cropping using <code>crop</code>).</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code> or <code>callable</code> or <code>list</code> of <code>str</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>
<p>name of a named Matplotlib colormap used to color the data. see the
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">Matplotlib documentation</a>
for more information. The default is <code>'inferno'</code>.</p>
<p>In addition to the colormaps listed there, the following maps for
linearly incrementing pure RGB channels are available, useful for
e.g. displaying multichannel data with complementary colors (no
overlap between between colormaps possible):
<code>['pure_reds', 'pure_greens', 'pure_blues', 'pure_yellows',
'pure_cyans', 'pure_purples','pure_greys']</code>
where for example <code>'pure_reds'</code> scales between RGB values <code>(0,0,0)</code>
and
<code>(255,0,0)</code>, and <code>'pure_cyans'</code> between <code>(0,0,0)</code> and
<code>(0,255,255)</code>.</p>
<p>Alternatively, a fully custom colormap may be used by entering a
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.ListedColormap.html#matplotlib.colors.ListedColormap">ListedColormap</a>
or <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html#matplotlib.colors.LinearSegmentedColormap">LinearSegmentedColormap</a>
object from the Matplotlib.colors module. For more information on
creating colormaps, see the Matplotlib documentation linked above.</p>
<p>For multichannel data, a list of colormaps <em>must</em> be provided, with
a separate colormap for each channel.</p>
</dd>
<dt><strong><code>cmap_range</code></strong> :&ensp;<code>tuple</code> of <code>form (min,max)</code> or <code>None</code> or <code>'automatic'</code>, optional</dt>
<dd>sets the scaling of the colormap. The minimum and maximum
values to map the colormap to, values outside of this range will
be colored according to the min and max value of the colormap. The
default is
<code>None</code>, which is to take the lowest and highest value
in the image. Alternatively <code>'automatic'</code> may be specified which
scales between the 10th and 99th percentile. For multichannel data
a list of cmap_range options per channel may be provided.</dd>
<dt><strong><code>draw_bar</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>whether to draw a scalebar on the image, such that this function
may be used to put other text on the image or just to apply a
colormap (by setting <code>draw_bar=False</code> and <code>draw_text=False</code>). The
default is <code>True</code>.</dd>
<dt><strong><code>barsize</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>size (in data units matching the original scale bar, e.g. nm) of
the scale bar to use. The default <code>None</code>, wich takes the desired
length for the current scale (ca. 15% of the width of the image for
<code>scale=1</code>) and round this to the nearest option from a list of
"nice" values.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>factor to change the size of the scalebar+text with respect to the
width of the image. Scale is chosen such, that at <code>scale=1</code> the
font size of the scale bar text is approximately 10 pt when
the image is printed at half the width of the text in a typical A4
paper document (e.g. two images side-by-side). Note that this is
with respect to the <strong>output</strong> image, so after optional cropping
and/or up/down sampling has been applied. The default is <code>1</code>.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>int, one</code> of <code>[</code>0<code>,</code>1<code>,</code>2<code>,</code>3<code>]</code>, optional</dt>
<dd>Location of the scalebar on the image, where <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>
refer to the top left, top right, bottom left and bottom right
respectively. The default is <code>2</code>, which is the bottom left corner.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>str, one</code> of <code>[</code>'fm'<code>,</code>'pm'<code>,</code>'Å'<code> or </code>A<code>,</code>'nm'<code>,</code>'µm'<code> or </code>'um'<code>,</code>'mm'<code>,</code>'cm'<code>,</code>'dm'<code>,</code>'m'<code>]</code>, optional</dt>
<dd>Unit that will be used for the scale bar, the value will be
automatically converted if this unit differs from the pixel size
unit. The default is <code>None</code>, which uses micrometers.</dd>
<dt><strong><code>barcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the scalebar and text, given as a tuple of
form (R,G,B) or (R,G,B,A) where R, G B and A are values between 0
and 255 for red, green, blue and alpha respectively. The default is
<code>(255,255,255)</code>, which gives a white scalebar.</dd>
<dt><strong><code>barthickness</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>thickness in printer points of the scale bar itself. The default is
16.</dd>
<dt><strong><code>barpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size in printer points of the padding between the scale bar and the
surrounding box. The default is 10.</dd>
<dt><strong><code>draw_text</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to draw the text specified in <code>text</code> on the image, the text
is place above the scale bar if <code>draw_bar=True</code>. The default is
<code>True</code>.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the text to draw on the image (above the scale bar if
<code>draw_bar=True</code>). The default is <code>None</code>, which gives the size and
unit of the scale bar (e.g. <code>'10 µm'</code>).</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename of an installed TrueType font ('.ttf' file) to use for the
text on the scalebar. The default is <code>'arialbd.ttf'</code>.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>base font size to use for the scale bar text. The default is 16.
Note that this size will be re-scaled according to <code>resolution</code> and
<code>scale</code>.</dd>
<dt><strong><code>fontcolor</code></strong> :&ensp;<code>tuple</code> of <code>int</code>, optional</dt>
<dd>(R,G,B) tuple where R, G and B are red, green and blue values from
0 to 255. The default is (255,255,255) giving white text.</dd>
<dt><strong><code>fontbaseline</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>vertical offset for the baseline of the scale bar text in from the
top of the scale bar in printer points. The default is 10.</dd>
<dt><strong><code>fontpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>minimum size in printer points of the space/padding between the
text and surrounding box. The default is 10.</dd>
<dt><strong><code>draw_box</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to put a colored box behind the scalebar and text to
enhance contrast on busy images. The default is <code>False</code>.</dd>
<dt><strong><code>boxcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the box behind/around the scalebar and text,
given as a tuple of form (R,G,B) or (R,G,B,A) where R, G B and A
are values between 0 and 255 for red, green and blue respectively.
If no A is given, <code>boxopacity</code> is used. The default is (0,0,0)
which gives a black box.</dd>
<dt><strong><code>boxopacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>value between 0 and 255 for the opacity/alpha of the box, useful
for creating a semitransparent box. The default is 255.</dd>
<dt><strong><code>boxpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size of the space/padding around the box (with respect to the sides
of the image) in printer points. The default is 10.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to save the image as file. The default is True.</dd>
<dt><strong><code>show_figure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to open matplotlib figure windows. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Y×X×4 numpy.array containing the BGRA pixel data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_channel"><code class="name flex">
<span>def <span class="ident">get_channel</span></span>(<span>self, chl)</span>
</code></dt>
<dd>
<div class="desc"><p>get info from the metadata on a specific channel</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chl</code></strong> :&ensp;<code>int</code></dt>
<dd>index number of the channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing all metadata for that channel</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_channels"><code class="name flex">
<span>def <span class="ident">get_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>parse the images xml data for the channels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>dictionaries</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_detector_settings"><code class="name flex">
<span>def <span class="ident">get_detector_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml metadata for the detector settings.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionary</code> or <code>(in case</code> of <code>multichannel data) a list thereof</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_dimension"><code class="name flex">
<span>def <span class="ident">get_dimension</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the dimension data for a particular dimension of an image.
Dimension can be given both as integer index (as specified by the Leica
MetaData which may not correspond to the indexing order of the data
stack) or as string containing the physical meaning, e.g. 'x-axis',
'time', 'excitation wavelength', etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get metadata of specified as integer or as name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing all metadata for that dimension</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_dimension_steps"><code class="name flex">
<span>def <span class="ident">get_dimension_steps</span></span>(<span>self, dim, load_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of corresponding physical values for all steps along
a given dimension, e.g. a list of time steps or x coordinates.
Dimension can be given both as integer index (as specified by the Leica
MetaData, which may not correspond to the indexing order of the data
stack), or as string containing the physical meaning, e.g. 'x-axis',
'time', 'excitation wavelength', etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get metadata of specified as integer or as name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>physical values of the steps along the chosen dimension, (e.g.
a list of pixel x-coordinates, list of time stamps, &hellip;).</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>physical unit of the data.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_dimension_stepsize"><code class="name flex">
<span>def <span class="ident">get_dimension_stepsize</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the step size along a dimension, e.g. time interval, pixel
size, etc, as (value, unit) tuple. Dimension can be given both as
integer index (as specified by the Leica MetaData, which may not
correspond to the indexing order of the data stack), or as string
containing the physical meaning, e.g. 'x-axis', 'time', 'excitation
wavelength', etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get metadata of specified as integer or as name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stepsize</code></strong> :&ensp;<code>float</code></dt>
<dd>physical size of one step (e.g. pixel, time interval, &hellip;).</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>physical unit of the data.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_dimensions"><code class="name flex">
<span>def <span class="ident">get_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>parse the images xml data for the dimensions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>dictionaries</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_laser_settings"><code class="name flex">
<span>def <span class="ident">get_laser_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml metadata for the laser settings.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionary with laser data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut for getting the name of the dataset / image for e.g.
automatically generating filenames for stored results.</p>
<p>The format is: <code>&lt;lif file name (without file extension)&gt;_&lt;image name&gt;</code></p></div>
</dd>
<dt id="scm_confocal.sp8_image.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shorthand for <code>get_dimension_stepsize()</code> to get the pixel/voxel size
converted to micrometer, along whatever spatial dimensions are present
in the data in order of slowest to fastest axis, i.e. typically (z,y,x)
but e.g. (y,z,x) for an xzy scan.
data are skipped.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code></dt>
<dd>physical size in µm of the pixels/voxels along (z,y,x)</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.get_stage_position"><code class="name flex">
<span>def <span class="ident">get_stage_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns base (z,y,x) position of the stage in micrometer</p></div>
</dd>
<dt id="scm_confocal.sp8_image.load_frame"><code class="name flex">
<span>def <span class="ident">load_frame</span></span>(<span>self, i=0, channel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns specified image frame where a frame is considered a 2D image in
the plane of the two fastes axes in the recording order (typically xy).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the index number of the requested image. The default is 0.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code> or <code>list</code> of <code>int</code>, optional</dt>
<dd>which channel(s) to return. For multiple channels, a tuple with an
numpy.ndarray for each image is returned, for a single channel a
single numpy.ndarray is returned. The default is to return all
channels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>tuple</code> of <code>numpy.ndarray</code></dt>
<dd>the raw image data values for the requested frame / channel(s)</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.load_plane"><code class="name flex">
<span>def <span class="ident">load_plane</span></span>(<span>self, display_dims=None, indices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>load 2D plane / slice of arbitrary orientation from the data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>display_dims</code></strong> :&ensp;<code>tuple</code> of <code>length 2</code>, optional</dt>
<dd>the 2 dimensions defining the 2D image plane to load. The default
is the imaging plane (the two fastest axes, typically xy).</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>index values for all other planes. The default is 0 for all dims.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>array containing the pixel values of the selected plane.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range=None, dtype=None, quiet=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to sp8_series.load_data(), but converts the 3D array of images
automatically to a np.ndarray of the appropriate dimensionality.</p>
<p>Array dimensions are specified as follows:</p>
<ul>
<li>
<p>If the number of detector channels is 2 or higher, the first
array axis is the detector channel index (named 'channel').</p>
</li>
<li>
<p>If the number of channels is 1, the first array axis is the first
available dimension (instead of 'channel').</p>
</li>
<li>
<p>Each subsequent array axis corresponds to a dimension as
specified by and in reversed order of the metadata exported by
the microscope software, excluding dimensions which are not
available. The default order of dimensions in the metadata is:</p>
<ol>
<li>
<p><code>'channel'</code> (excluded for single channel data)</p>
</li>
<li>
<p><code>'x-axis'</code></p>
</li>
<li>
<p><code>'y-axis'</code></p>
</li>
<li>
<p><code>'z-axis'</code></p>
</li>
<li>
<p><code>'time'</code></p>
</li>
<li>
<p><code>'detection wavelength'</code></p>
</li>
<li>
<p><code>'excitation wavelength'</code></p>
</li>
<li>
<p><code>'mosaic'</code></p>
</li>
</ol>
</li>
<li>
<p>As an example, a 2 channel xyt measurement would result in a 4-d
array with axis order ('channel','time','y-axis',
'x-axis'), and a single channel xyz scan would be returned as
('z-axis','y-axis','x-axis')</p>
</li>
</ul>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and int or slice objects as values. This allows you to only load
part of the data along any of the dimensions, such as only loading
one channel of multichannel data or a particular z-range. An
example use for only taking time steps up to 5 and z-slice 20 to 30
would be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>When an int is given, only that slice along the dimension is taken
and the dimensionis squeezed out of the data. The default is {}.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is None which uses the same bit
depth as the original image (either 8- or 16-bit unsigned int).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
<dt><strong><code>dimorder</code></strong> :&ensp;<code>tuple</code></dt>
<dd>tuple with lenght data.ndim specifying the ordering of dimensions
in the data with labels from the metadata of the microscope.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_image.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a somewhat formatted version of the full image metadata, the
xml hierarchy is indicated with prepended dashes.</p></div>
</dd>
<dt id="scm_confocal.sp8_image.save_metadata"><code class="name flex">
<span>def <span class="ident">save_metadata</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>stores the image xml metadata to a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename to use. The default is the result of <code>get_name()</code>
'_metadata.xml' appended.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.sp8_lif"><code class="flex name class">
<span>class <span class="ident">sp8_lif</span></span>
<span>(</span><span>filename=None, quiet=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class of functions related to the sp8 microscope, for data saved as .lif
files, the default file format for the Leica LAS-X software. Essentially
a wrapper around the <code>readlif</code> library, which provides access to the data
and metadata directly in Python.</p>
<p>The underlying <code>readlif.LifFile</code> instance can be accessed directly using
the <code>sp8_lif.liffile</code> attribute, and any of it attributes are accessible
through <code><a title="scm_confocal.sp8_lif" href="#scm_confocal.sp8_lif">sp8_lif</a></code> directly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename of the <code>.lif</code> file. Extension may be (but is not required to
be) included.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>can be used to suppress printing the contents of the file. The default
is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="scm_confocal.sp8_lif" href="#scm_confocal.sp8_lif">sp8_lif</a></code> class instance</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>liffile</code></strong> :&ensp;<code>readlif.LifFile instance</code></dt>
<dd>The underlying class instance of the readlif library.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the loaded .lif file with file extention included, even if
it was not given when initializing the class.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="scm_confocal.sp8_image" href="#scm_confocal.sp8_image">sp8_image</a></code></dt>
<dd>a subclass for specific images in the dataset.</dd>
<dt><code>readlif</code></dt>
<dd>the library used for acessing the files, which can be found
<a href="https://github.com/nimne/readlif">here</a> Initialize the class instance and the underlying LifFile instance</dd>
</dl></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>scm_confocal.sp8.sp8_image</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.sp8_lif.get_image"><code class="name flex">
<span>def <span class="ident">get_image</span></span>(<span>self, image=0)</span>
</code></dt>
<dd>
<div class="desc"><p>returns an sp8_image instance containing relevant attributes and
functions for the specific image in the dataset, which provides the
"bread and butter" of data access.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>The image (or image series) to obtain. May be given as index number
(int) or as the name of the series (string). The default is the
first image in the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="scm_confocal.sp8_image" href="#scm_confocal.sp8_image">sp8_image</a></code> class instance</p></div>
</dd>
<dt id="scm_confocal.sp8_lif.get_liffile_image"><code class="name flex">
<span>def <span class="ident">get_liffile_image</span></span>(<span>self, image=0)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the <code>readlif.LifImage</code> instance for a particular image in the
dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>The image (or image series) to obtain. May be given as index number
(int) or as the name of the series (string). The default is the
first image in the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>readlif.LifImage</code> class instance</p></div>
</dd>
<dt id="scm_confocal.sp8_lif.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut for getting the name (filename sans extention) of the dataset
for e.g. automatically generating filenames for stored results.</p></div>
</dd>
<dt id="scm_confocal.sp8_lif.save_metadata"><code class="name flex">
<span>def <span class="ident">save_metadata</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>stores the xml metadata to a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename to use. The default is the name of the Lif file with
'_metadata.xml' appended.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.sp8_series"><code class="flex name class">
<span>class <span class="ident">sp8_series</span></span>
<span>(</span><span>fmt='*.tif')</span>
</code></dt>
<dd>
<div class="desc"><p>Class of functions related to the sp8 microscope. The functions assume that
the data are exported as .tif files and placed in a own folder per series.
The current working directory is assumed to be that folder. For several
functions it is required that the xml metadata is present in a subfolder of
the working directory called 'MetaData', which is normally generated
automatically when exporting tif files as raw data.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>the filenames loaded associated with the series</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>the image data as loaded on the most recent call of
sp8_series.load_data()</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>xml.Elementtree root</code></dt>
<dd>the recording parameters associated with the image series</dd>
</dl>
<p>Initialize the class instance and assign the filenames of the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>format to use for finding the files. Uses the notation of the glob
library. The default is '*.tif'.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.sp8_series.export_with_scalebar"><code class="name flex">
<span>def <span class="ident">export_with_scalebar</span></span>(<span>self, frame=0, channel=0, filename=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>saves an exported image of the confocal slice with a scalebar in one of
the four corners, where barsize is the scalebar size in data units
(e.g. µm) and scale the overall size of the scalebar and text with
respect to the width of the image. Additionally, a colormap is applied
to the data for better visualisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>index of the frame to export. The default is 0.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code> or <code>list</code> of <code>int</code>, optional</dt>
<dd>the channel to pull the image data from. For displaying multiple
channels in a single image, a list of channel indices can be given,
as well as a list of colormaps for each channel through the <code>cmap</code>
parameter. The default is <code>0</code>.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code>, optional</dt>
<dd>Filename + extension to use for the export file. The default is the
filename sans extension of the original TEM file, with
'_exported.png' appended.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>
<p>range describing a area of the original image (before rescaling the
resolution) to crop out for the export image. Can have two forms:</p>
<ul>
<li>
<p><code>((xmin,ymin),(xmax,ymax))</code>, with the integer indices of the top
left and bottom right corners respectively.</p>
</li>
<li>
<p><code>(xmin,ymin,w,h)</code> with the integer indices of the top left corner
and the width and heigth of the cropped image in pixels (prior to
optional rescaling using <code>resolution</code>).</p>
</li>
</ul>
<p>The default is <code>None</code> which takes the entire image.</p>
</dd>
<dt><strong><code>crop_unit</code></strong> :&ensp;<code>'pixels'</code> or <code>'data'</code>, optional</dt>
<dd>sets the unit in which the width and height in <code>crop</code> are
specified when using the (x,y,w,h) format, with <code>'pixels'</code> to give
the size in pixels or <code>'data'</code> to specify the size in the physical
unit used for the scalebar (after optional unit conversion via the
<code>convert</code> parameter). Note that the position of the top left corner
is given in pixels. The <code>((xmin,ymin),(xmax,ymax))</code> format must be
always given in pixels, and <code>crop_unit</code> is ignored if <code>crop</code> is
given in this format. The default is <code>'pixels'</code>.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the resolution along the x-axis (i.e. image width in pixels) to use
for the exported image. The default is <code>None</code>, which uses the size
of the original image (after optional cropping using <code>crop</code>).</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code> or <code>callable</code> or <code>list</code> of <code>str</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>
<p>name of a named Matplotlib colormap used to color the data. see the
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">Matplotlib documentation</a>
for more information. The default is <code>'inferno'</code>.</p>
<p>In addition to the colormaps listed there, the following maps for
linearly incrementing pure RGB channels are available, useful for
e.g. displaying multichannel data with complementary colors (no
overlap between between colormaps possible):
<code>['pure_reds', 'pure_greens', 'pure_blues', 'pure_yellows',
'pure_cyans', 'pure_purples','pure_greys']</code>
where for example <code>'pure_reds'</code> scales between RGB values <code>(0,0,0)</code>
and
<code>(255,0,0)</code>, and <code>'pure_cyans'</code> between <code>(0,0,0)</code> and
<code>(0,255,255)</code>.</p>
<p>Alternatively, a fully custom colormap may be used by entering a
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.ListedColormap.html#matplotlib.colors.ListedColormap">ListedColormap</a>
or <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html#matplotlib.colors.LinearSegmentedColormap">LinearSegmentedColormap</a>
object from the Matplotlib.colors module. For more information on
creating colormaps, see the Matplotlib documentation linked above.</p>
<p>For multichannel data, a list of colormaps <em>must</em> be provided, with
a separate colormap for each channel.</p>
</dd>
<dt><strong><code>cmap_range</code></strong> :&ensp;<code>tuple</code> of <code>form (min,max)</code> or <code>None</code> or <code>'automatic'</code>, optional</dt>
<dd>sets the scaling of the colormap. The minimum and maximum
values to map the colormap to, values outside of this range will
be colored according to the min and max value of the colormap. The
default is
<code>None</code>, which is to take the lowest and highest value
in the image. Alternatively <code>'automatic'</code> may be specified which
scales between the 10th and 99th percentile. For multichannel data
a list of cmap_range options per channel may be provided.</dd>
<dt><strong><code>draw_bar</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>whether to draw a scalebar on the image, such that this function
may be used to put other text on the image or just to apply a
colormap (by setting <code>draw_bar=False</code> and <code>draw_text=False</code>). The
default is <code>True</code>.</dd>
<dt><strong><code>barsize</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>size (in data units matching the original scale bar, e.g. nm) of
the scale bar to use. The default <code>None</code>, wich takes the desired
length for the current scale (ca. 15% of the width of the image for
<code>scale=1</code>) and round this to the nearest option from a list of
"nice" values.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>factor to change the size of the scalebar+text with respect to the
width of the image. Scale is chosen such, that at <code>scale=1</code> the
font size of the scale bar text is approximately 10 pt when
the image is printed at half the width of the text in a typical A4
paper document (e.g. two images side-by-side). Note that this is
with respect to the <strong>output</strong> image, so after optional cropping
and/or up/down sampling has been applied. The default is <code>1</code>.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>int, one</code> of <code>[</code>0<code>,</code>1<code>,</code>2<code>,</code>3<code>]</code>, optional</dt>
<dd>Location of the scalebar on the image, where <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>
refer to the top left, top right, bottom left and bottom right
respectively. The default is <code>2</code>, which is the bottom left corner.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>str, one</code> of <code>[</code>'fm'<code>,</code>'pm'<code>,</code>'Å'<code> or </code>A<code>,</code>'nm'<code>,</code>'µm'<code> or </code>'um'<code>,</code>'mm'<code>,</code>'cm'<code>,</code>'dm'<code>,</code>'m'<code>]</code>, optional</dt>
<dd>Unit that will be used for the scale bar, the value will be
automatically converted if this unit differs from the pixel size
unit. The default is <code>None</code>, which uses micrometers.</dd>
<dt><strong><code>barcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the scalebar and text, given as a tuple of
form (R,G,B) or (R,G,B,A) where R, G B and A are values between 0
and 255 for red, green, blue and alpha respectively. The default is
<code>(255,255,255)</code>, which gives a white scalebar.</dd>
<dt><strong><code>barthickness</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>thickness in printer points of the scale bar itself. The default is
16.</dd>
<dt><strong><code>barpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size in printer points of the padding between the scale bar and the
surrounding box. The default is 10.</dd>
<dt><strong><code>draw_text</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to draw the text specified in <code>text</code> on the image, the text
is place above the scale bar if <code>draw_bar=True</code>. The default is
<code>True</code>.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the text to draw on the image (above the scale bar if
<code>draw_bar=True</code>). The default is <code>None</code>, which gives the size and
unit of the scale bar (e.g. <code>'10 µm'</code>).</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename of an installed TrueType font ('.ttf' file) to use for the
text on the scalebar. The default is <code>'arialbd.ttf'</code>.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>base font size to use for the scale bar text. The default is 16.
Note that this size will be re-scaled according to <code>resolution</code> and
<code>scale</code>.</dd>
<dt><strong><code>fontcolor</code></strong> :&ensp;<code>tuple</code> of <code>int</code>, optional</dt>
<dd>(R,G,B) tuple where R, G and B are red, green and blue values from
0 to 255. The default is (255,255,255) giving white text.</dd>
<dt><strong><code>fontbaseline</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>vertical offset for the baseline of the scale bar text in from the
top of the scale bar in printer points. The default is 10.</dd>
<dt><strong><code>fontpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>minimum size in printer points of the space/padding between the
text and surrounding box. The default is 10.</dd>
<dt><strong><code>draw_box</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to put a colored box behind the scalebar and text to
enhance contrast on busy images. The default is <code>False</code>.</dd>
<dt><strong><code>boxcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the box behind/around the scalebar and text,
given as a tuple of form (R,G,B) or (R,G,B,A) where R, G B and A
are values between 0 and 255 for red, green and blue respectively.
If no A is given, <code>boxopacity</code> is used. The default is (0,0,0)
which gives a black box.</dd>
<dt><strong><code>boxopacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>value between 0 and 255 for the opacity/alpha of the box, useful
for creating a semitransparent box. The default is 255.</dd>
<dt><strong><code>boxpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size of the space/padding around the box (with respect to the sides
of the image) in printer points. The default is 10.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to save the image as file. The default is True.</dd>
<dt><strong><code>show_figure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to open matplotlib figure windows. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Y×X×4 numpy.array containing the BGRA pixel data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_dimension_steps"><code class="name flex">
<span>def <span class="ident">get_dimension_steps</span></span>(<span>self, dim, load_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of values for each step along the specified dimension, e.g.
a list of timestamps for the images or a list of height values for all
slices of a z-stack. For specification of dimensions, see
sp8_series.get_metadata_dimension()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get steps for</dd>
<dt><strong><code>load_stack_indices</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, trims down the list of steps based on the dim_range used
when last loading data with load_stack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>list</code></dt>
<dd>list of values for every logical step in the data</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>physical unit of the step values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_dimension_stepsize"><code class="name flex">
<span>def <span class="ident">get_dimension_stepsize</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of a single step along the specified dimension, e.g.
the pixelsize in x, y or z, or the time between timesteps. For
specification of dimensions, see sp8_series.get_metadata_dimension()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get stepsize for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>stepsize</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>int</code></dt>
<dd>physical unit of value</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_laser_settings"><code class="name flex">
<span>def <span class="ident">get_laser_settings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the xml metadata for the laser settings.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionary with laser data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_channels"><code class="name flex">
<span>def <span class="ident">get_metadata_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the channel information from the metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>channels</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>list of dictionaries with length equal to number of channels where
each dict contains the metadata for one channel</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_dimension"><code class="name flex">
<span>def <span class="ident">get_metadata_dimension</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the dimension data for a particular dimension. Dimension can be
given both as integer index (as specified by the Leica exported
MetaData which may not correspond to the indexing order of the data
stack) or as string containing the physical meaning, e.g. 'x-axis',
'time', 'excitation wavelength', etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get metadata of specified as integer or as name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing all metadata for that dimension</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_dimensions"><code class="name flex">
<span>def <span class="ident">get_metadata_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the dimension information from the metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>list of dictionaries with length number of dimensions where
each dict contains the metadata for one data dimension</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string containing the filename (sans file extension) under
which the series is saved.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the series</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shorthand for <code>get_dimension_stepsize()</code> to get the pixel/voxel size
converted to micrometer, along whatever spatial dimensions are present
in the data. Is given as (z,y,x) where dimensions not present in the
data are skipped.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsize</code></strong> :&ensp;<code>tuple</code> of <code>float</code></dt>
<dd>physical size in µm of the pixels/voxels along (z,y,x)</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_series_name"><code class="name flex">
<span>def <span class="ident">get_series_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated, renamed to <code>get_name()</code></p></div>
</dd>
<dt id="scm_confocal.sp8_series.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, filenames=None, first=None, last=None, dtype=numpy.uint8)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the sequence of images into ndarray of form (files,y,x) and
converts the data to dtype</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>filenames of images to load. The default is what is passed from
<strong>init</strong>, which by default is all .tif images in the current
working directory.</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>None</code> or <code>int</code>, optional</dt>
<dd>index of first image to load. The default is None.</dd>
<dt><strong><code>last</code></strong> :&ensp;<code>None</code> or <code>int</code>, optional</dt>
<dd>index of last image to load plus one. The default is None.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>3d numpy array with dimension order (filenames,y,x).</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.load_metadata"><code class="name flex">
<span>def <span class="ident">load_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the xml metadata exported with the files as xml_root object which
can be indexed with xml.etree.ElementTree</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>xml.etree.ElementTree object</code></dt>
<dd>Parsable xml tree object containing all the metadata</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range=None, dtype=numpy.uint8)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to sp8_series.load_data(), but converts the 3D array of images
automatically to a np.ndarray of the appropriate dimensionality.</p>
<p>Array dimensions are specified as follows:</p>
<ul>
<li>
<p>If the number of detector channels is 2 or higher, the first
array axis is the detector channel index (named 'channel').</p>
</li>
<li>
<p>If the number of channels is 1, the first array axis is the first
available dimension (instead of 'channel').</p>
</li>
<li>
<p>Each subsequent array axis corresponds to a dimension as
specified by and in reversed order of the metadata exported by
the microscope software, excluding dimensions which are not
available. The default order of dimensions in the metadata is:</p>
<ol>
<li>
<p><code>'channel'</code> (excluded for single channel data)</p>
</li>
<li>
<p><code>'x-axis'</code></p>
</li>
<li>
<p><code>'y-axis'</code></p>
</li>
<li>
<p><code>'z-axis'</code></p>
</li>
<li>
<p><code>'time'</code></p>
</li>
<li>
<p><code>'detection wavelength'</code></p>
</li>
<li>
<p><code>'excitation wavelength'</code></p>
</li>
</ol>
</li>
<li>
<p>As an example, a 2 channel xyt measurement would result in a 4-d
array with axis order ('channel','time','y-axis',
'x-axis'), and a single channel xyz scan would be returned as
('z-axis','y-axis','x-axis')</p>
</li>
</ul>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and int or slice objects as values. This allows you to only load
part of the data along any of the dimensions, such as only loading
one channel of multichannel data or a particular z-range. An
example use for only taking time steps up to 5 and z-slice 20 to 30
would be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>When an int is given, only that slice along the dimension is taken
and the dimensionis squeezed out of the data. The default is {}.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
<dt><strong><code>dimorder</code></strong> :&ensp;<code>tuple</code></dt>
<dd>tuple with lenght data.ndim specifying the ordering of dimensions
in the data with labels from the metadata of the microscope.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.visitech_faststack"><code class="flex name class">
<span>class <span class="ident">visitech_faststack</span></span>
<span>(</span><span>filename, zsize, zstep, zbacksteps, zstart=0, magnification=63, binning=1)</span>
</code></dt>
<dd>
<div class="desc"><p>functions for fast stacks taken with the custom MicroManager Visitech
driver, saved to multipage .ome.tiff files containing entire stack</p>
<p>initialize class (lazy-loads data)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>string</code></dt>
<dd>name of first ome.tiff file (extension optional)</dd>
<dt><strong><code>zsize</code></strong> :&ensp;<code>float</code></dt>
<dd>z size (in um) of stack (first im to last)</dd>
<dt><strong><code>zstep</code></strong> :&ensp;<code>float</code></dt>
<dd>step size in z</dd>
<dt><strong><code>zbacksteps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of backwards steps in z direction after each stack</dd>
<dt><strong><code>zstart</code></strong> :&ensp;<code>float</code></dt>
<dd>actual height of bottom of stack/lowest slice. The default is 0.</dd>
<dt><strong><code>magnification</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>magnification of objective lens used. The default is 63.</dd>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code></dt>
<dd>binning factor performed at the detector level, e.g. in
MicroManager software, in XY</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.visitech_faststack.export_with_scalebar"><code class="name flex">
<span>def <span class="ident">export_with_scalebar</span></span>(<span>self, stack=0, zslice=0, filename=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>saves an exported image of the confocal slice with a scalebar in one of
the four corners, where barsize is the scalebar size in data units
(e.g. µm) and scale the overall size of the scalebar and text with
respect to the width of the image. Additionally, a colormap is applied
to the data for better visualisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stack</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>integer index of the z-stack to take the frame to export from. The
default is <code>0</code>.</dd>
<dt><strong><code>zslice</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>integer index of the frame within <code>stack</code> to export. The default is
<code>0</code>.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code>, optional</dt>
<dd>Filename + extension to use for the export file. The default is the
filename sans extension of the original TEM file, with
'_exported.png' appended.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>
<p>range describing a area of the original image (before rescaling the
resolution) to crop out for the export image. Can have two forms:</p>
<ul>
<li>
<p><code>((xmin,ymin),(xmax,ymax))</code>, with the integer indices of the top
left and bottom right corners respectively.</p>
</li>
<li>
<p><code>(xmin,ymin,w,h)</code> with the integer indices of the top left corner
and the width and heigth of the cropped image in pixels (prior to
optional rescaling using <code>resolution</code>).</p>
</li>
</ul>
<p>The default is <code>None</code> which takes the entire image.</p>
</dd>
<dt><strong><code>crop_unit</code></strong> :&ensp;<code>'pixels'</code> or <code>'data'</code>, optional</dt>
<dd>sets the unit in which the width and height in <code>crop</code> are
specified when using the (x,y,w,h) format, with <code>'pixels'</code> to give
the size in pixels or <code>'data'</code> to specify the size in the physical
unit used for the scalebar (after optional unit conversion via the
<code>convert</code> parameter). Note that the position of the top left corner
is given in pixels. The <code>((xmin,ymin),(xmax,ymax))</code> format must be
always given in pixels, and <code>crop_unit</code> is ignored if <code>crop</code> is
given in this format. The default is <code>'pixels'</code>.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the resolution along the x-axis (i.e. image width in pixels) to use
for the exported image. The default is <code>None</code>, which uses the size
of the original image (after optional cropping using <code>crop</code>).</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code> or <code>callable</code> or <code>list</code> of <code>str</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>
<p>name of a named Matplotlib colormap used to color the data. see the
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">Matplotlib documentation</a>
for more information. The default is <code>'inferno'</code>.</p>
<p>In addition to the colormaps listed there, the following maps for
linearly incrementing pure RGB channels are available, useful for
e.g. displaying multichannel data with complementary colors (no
overlap between between colormaps possible):
<code>['pure_reds', 'pure_greens', 'pure_blues', 'pure_yellows',
'pure_cyans', 'pure_purples','pure_greys']</code>
where for example <code>'pure_reds'</code> scales between RGB values <code>(0,0,0)</code>
and
<code>(255,0,0)</code>, and <code>'pure_cyans'</code> between <code>(0,0,0)</code> and
<code>(0,255,255)</code>.</p>
<p>Alternatively, a fully custom colormap may be used by entering a
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.ListedColormap.html#matplotlib.colors.ListedColormap">ListedColormap</a>
or <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html#matplotlib.colors.LinearSegmentedColormap">LinearSegmentedColormap</a>
object from the Matplotlib.colors module. For more information on
creating colormaps, see the Matplotlib documentation linked above.</p>
<p>For multichannel data, a list of colormaps <em>must</em> be provided, with
a separate colormap for each channel.</p>
</dd>
<dt><strong><code>cmap_range</code></strong> :&ensp;<code>tuple</code> of <code>form (min,max)</code> or <code>None</code> or <code>'automatic'</code>, optional</dt>
<dd>sets the scaling of the colormap. The minimum and maximum
values to map the colormap to, values outside of this range will
be colored according to the min and max value of the colormap. The
default is
<code>None</code>, which is to take the lowest and highest value
in the image. Alternatively <code>'automatic'</code> may be specified which
scales between the 10th and 99th percentile. For multichannel data
a list of cmap_range options per channel may be provided.</dd>
<dt><strong><code>draw_bar</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>whether to draw a scalebar on the image, such that this function
may be used to put other text on the image or just to apply a
colormap (by setting <code>draw_bar=False</code> and <code>draw_text=False</code>). The
default is <code>True</code>.</dd>
<dt><strong><code>barsize</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>size (in data units matching the original scale bar, e.g. nm) of
the scale bar to use. The default <code>None</code>, wich takes the desired
length for the current scale (ca. 15% of the width of the image for
<code>scale=1</code>) and round this to the nearest option from a list of
"nice" values.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>factor to change the size of the scalebar+text with respect to the
width of the image. Scale is chosen such, that at <code>scale=1</code> the
font size of the scale bar text is approximately 10 pt when
the image is printed at half the width of the text in a typical A4
paper document (e.g. two images side-by-side). Note that this is
with respect to the <strong>output</strong> image, so after optional cropping
and/or up/down sampling has been applied. The default is <code>1</code>.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>int, one</code> of <code>[</code>0<code>,</code>1<code>,</code>2<code>,</code>3<code>]</code>, optional</dt>
<dd>Location of the scalebar on the image, where <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>
refer to the top left, top right, bottom left and bottom right
respectively. The default is <code>2</code>, which is the bottom left corner.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>str, one</code> of <code>[</code>'fm'<code>,</code>'pm'<code>,</code>'Å'<code> or </code>A<code>,</code>'nm'<code>,</code>'µm'<code> or </code>'um'<code>,</code>'mm'<code>,</code>'cm'<code>,</code>'dm'<code>,</code>'m'<code>]</code>, optional</dt>
<dd>Unit that will be used for the scale bar, the value will be
automatically converted if this unit differs from the pixel size
unit. The default is <code>None</code>, which uses micrometers.</dd>
<dt><strong><code>barcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the scalebar and text, given as a tuple of
form (R,G,B) or (R,G,B,A) where R, G B and A are values between 0
and 255 for red, green, blue and alpha respectively. The default is
<code>(255,255,255)</code>, which gives a white scalebar.</dd>
<dt><strong><code>barthickness</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>thickness in printer points of the scale bar itself. The default is
16.</dd>
<dt><strong><code>barpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size in printer points of the padding between the scale bar and the
surrounding box. The default is 10.</dd>
<dt><strong><code>draw_text</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to draw the text specified in <code>text</code> on the image, the text
is place above the scale bar if <code>draw_bar=True</code>. The default is
<code>True</code>.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the text to draw on the image (above the scale bar if
<code>draw_bar=True</code>). The default is <code>None</code>, which gives the size and
unit of the scale bar (e.g. <code>'10 µm'</code>).</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename of an installed TrueType font ('.ttf' file) to use for the
text on the scalebar. The default is <code>'arialbd.ttf'</code>.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>base font size to use for the scale bar text. The default is 16.
Note that this size will be re-scaled according to <code>resolution</code> and
<code>scale</code>.</dd>
<dt><strong><code>fontcolor</code></strong> :&ensp;<code>tuple</code> of <code>int</code>, optional</dt>
<dd>(R,G,B) tuple where R, G and B are red, green and blue values from
0 to 255. The default is (255,255,255) giving white text.</dd>
<dt><strong><code>fontbaseline</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>vertical offset for the baseline of the scale bar text in from the
top of the scale bar in printer points. The default is 10.</dd>
<dt><strong><code>fontpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>minimum size in printer points of the space/padding between the
text and surrounding box. The default is 10.</dd>
<dt><strong><code>draw_box</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to put a colored box behind the scalebar and text to
enhance contrast on busy images. The default is <code>False</code>.</dd>
<dt><strong><code>boxcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the box behind/around the scalebar and text,
given as a tuple of form (R,G,B) or (R,G,B,A) where R, G B and A
are values between 0 and 255 for red, green and blue respectively.
If no A is given, <code>boxopacity</code> is used. The default is (0,0,0)
which gives a black box.</dd>
<dt><strong><code>boxopacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>value between 0 and 255 for the opacity/alpha of the box, useful
for creating a semitransparent box. The default is 255.</dd>
<dt><strong><code>boxpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size of the space/padding around the box (with respect to the sides
of the image) in printer points. The default is 10.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to save the image as file. The default is True.</dd>
<dt><strong><code>show_figure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to open matplotlib figure windows. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Y×X×4 numpy.array containing the BGRA pixel data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns xml tree
object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree</code></dt>
<dd>formatted XML metadata. Can be indexed with
xml_root.find('<element name>')</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut to get (z,y,x) pixelsize with unit</p></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_series_name"><code class="name flex">
<span>def <span class="ident">get_series_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a name for the series based on the filename.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_timestamps"><code class="name flex">
<span>def <span class="ident">get_timestamps</span></span>(<span>self, load_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns timestamps</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>load_stack_indices</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True, only returns timestamps from frames which were loaded
at call to visitech_faststack.load_stack(), and using the same
dimension order / stack shape</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>numpy (nd)array</code> of <code>floats</code></dt>
<dd>list/stack of timestamps for each of the the frames in the data</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, indices=slice(None, None, None), dtype=numpy.uint16, xslice=None, yslice=None)</span>
</code></dt>
<dd>
<div class="desc"><p>load images from datafile into 3D numpy array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code> or <code>list</code> of <code>ints</code>, optional</dt>
<dd>which images from tiffstack to load. The default is
slice(None,None,None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray containing image data in dim order (im,y,x)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True, offset=0, force_reshape=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data and reshape into 4D stack with the following dimension
order: ('time','z-axis','y-axis','x-axis')</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the <code>x</code> or <code>y</code> axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified <code>x</code> or <code>y</code> axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>offset the indices by a constant number of frames in case the first
im is not the first slice of the first stack</dd>
<dt><strong><code>force_reshape</code></strong> :&ensp;<code>bool</code></dt>
<dd>in case of incorrect number of steps during acquisition, you can
use this to ignore the reshape-error occuring upon trying to sort
2d images into 4d stack series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.save_stack"><code class="name flex">
<span>def <span class="ident">save_stack</span></span>(<span>self, data, filename_prefix='visitech_faststack', sequence_type='multipage')</span>
</code></dt>
<dd>
<div class="desc"><p>save stacks to tiff files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy ndarray with 3</code> or <code>4 dimensions</code></dt>
<dd>image series pixel values with dimension order (z,y,x) or (t,z,y,x)</dd>
<dt><strong><code>filename_prefix</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>prefix to use for filename. The time/z-axis index is appended if
relevant. The default is 'visitech_faststack'.</dd>
<dt><strong><code>sequence_type</code></strong> :&ensp;<code>{'multipage','image_sequence','multipage_sequence'}</code>, optional</dt>
<dd>
<p>The way to store the data. The following options are available:</p>
<pre><code>- 'image_sequence' : stores as a series of 2D images with time 
and or frame number appended
- 'multipage' : store all data in a single multipage tiff file
- 'multipage_sequence' : stores a multipage tiff file for each 
time step
</code></pre>
<p>The default is 'multipage'.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None, but writes file(s) to working directory.</p></div>
</dd>
<dt id="scm_confocal.visitech_faststack.yield_stack"><code class="name flex">
<span>def <span class="ident">yield_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True, offset=0, force_reshape=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy-load the data and reshape into 4D stack with the following
dimension order: ('time','z-axis','y-axis','x-axis'). Returns a
generator which yields a z-stack for each call, which is loaded upon
calling it.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.
The shape of the stack can be accessed without loading data using the
stack_shape attribute after creating the yield_stack object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>offset the indices by a constant number of frames in case the first
im is not the first slice of the first stack</dd>
<dt><strong><code>force_reshape</code></strong> :&ensp;<code>bool</code></dt>
<dd>in case of incorrect number of steps during acquisition, you can
use this to ignore the reshape-error occuring upon trying to sort
2d images into 4d stack series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zstack</code></strong> :&ensp;<code>iterable/generator yielding numpy.ndarray</code></dt>
<dd>list of time steps, with for each time step a z-stack as np.ndarray
with the pixel values</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.visitech_series"><code class="flex name class">
<span>class <span class="ident">visitech_series</span></span>
<span>(</span><span>filename, magnification=63, binning=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Functions for image series taken with the multi-D acquisition menu in
MicroManager with the Visitech saved to multipage .ome.tiff files. For the
custom fast stack sequence use visitech_faststack.</p>
<p>initialize class (lazy-loads data)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>string</code></dt>
<dd>name of first ome.tiff file (extension optional)</dd>
<dt><strong><code>magnification</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>magnification of objective lens used. The default is 63.</dd>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code></dt>
<dd>binning factor performed at the detector level, e.g. in
MicroManager software, in XY</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.visitech_series.export_with_scalebar"><code class="name flex">
<span>def <span class="ident">export_with_scalebar</span></span>(<span>self, frame=0, filename=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>saves an exported image of the confocal slice with a scalebar in one of
the four corners, where barsize is the scalebar size in data units
(e.g. µm) and scale the overall size of the scalebar and text with
respect to the width of the image. Additionally, a colormap is applied
to the data for better visualisation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>index of the frame to export. The default is 0.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code>, optional</dt>
<dd>Filename + extension to use for the export file. The default is the
filename sans extension of the original TEM file, with
'_exported.png' appended.</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>tuple</code> or <code>None</code>, optional</dt>
<dd>
<p>range describing a area of the original image (before rescaling the
resolution) to crop out for the export image. Can have two forms:</p>
<ul>
<li>
<p><code>((xmin,ymin),(xmax,ymax))</code>, with the integer indices of the top
left and bottom right corners respectively.</p>
</li>
<li>
<p><code>(xmin,ymin,w,h)</code> with the integer indices of the top left corner
and the width and heigth of the cropped image in pixels (prior to
optional rescaling using <code>resolution</code>).</p>
</li>
</ul>
<p>The default is <code>None</code> which takes the entire image.</p>
</dd>
<dt><strong><code>crop_unit</code></strong> :&ensp;<code>'pixels'</code> or <code>'data'</code>, optional</dt>
<dd>sets the unit in which the width and height in <code>crop</code> are
specified when using the (x,y,w,h) format, with <code>'pixels'</code> to give
the size in pixels or <code>'data'</code> to specify the size in the physical
unit used for the scalebar (after optional unit conversion via the
<code>convert</code> parameter). Note that the position of the top left corner
is given in pixels. The <code>((xmin,ymin),(xmax,ymax))</code> format must be
always given in pixels, and <code>crop_unit</code> is ignored if <code>crop</code> is
given in this format. The default is <code>'pixels'</code>.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the resolution along the x-axis (i.e. image width in pixels) to use
for the exported image. The default is <code>None</code>, which uses the size
of the original image (after optional cropping using <code>crop</code>).</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code> or <code>callable</code> or <code>list</code> of <code>str</code> or <code>list</code> of <code>callable</code>, optional</dt>
<dd>
<p>name of a named Matplotlib colormap used to color the data. see the
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">Matplotlib documentation</a>
for more information. The default is <code>'inferno'</code>.</p>
<p>In addition to the colormaps listed there, the following maps for
linearly incrementing pure RGB channels are available, useful for
e.g. displaying multichannel data with complementary colors (no
overlap between between colormaps possible):
<code>['pure_reds', 'pure_greens', 'pure_blues', 'pure_yellows',
'pure_cyans', 'pure_purples','pure_greys']</code>
where for example <code>'pure_reds'</code> scales between RGB values <code>(0,0,0)</code>
and
<code>(255,0,0)</code>, and <code>'pure_cyans'</code> between <code>(0,0,0)</code> and
<code>(0,255,255)</code>.</p>
<p>Alternatively, a fully custom colormap may be used by entering a
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.ListedColormap.html#matplotlib.colors.ListedColormap">ListedColormap</a>
or <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.colors.LinearSegmentedColormap.html#matplotlib.colors.LinearSegmentedColormap">LinearSegmentedColormap</a>
object from the Matplotlib.colors module. For more information on
creating colormaps, see the Matplotlib documentation linked above.</p>
<p>For multichannel data, a list of colormaps <em>must</em> be provided, with
a separate colormap for each channel.</p>
</dd>
<dt><strong><code>cmap_range</code></strong> :&ensp;<code>tuple</code> of <code>form (min,max)</code> or <code>None</code> or <code>'automatic'</code>, optional</dt>
<dd>sets the scaling of the colormap. The minimum and maximum
values to map the colormap to, values outside of this range will
be colored according to the min and max value of the colormap. The
default is
<code>None</code>, which is to take the lowest and highest value
in the image. Alternatively <code>'automatic'</code> may be specified which
scales between the 10th and 99th percentile. For multichannel data
a list of cmap_range options per channel may be provided.</dd>
<dt><strong><code>draw_bar</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>whether to draw a scalebar on the image, such that this function
may be used to put other text on the image or just to apply a
colormap (by setting <code>draw_bar=False</code> and <code>draw_text=False</code>). The
default is <code>True</code>.</dd>
<dt><strong><code>barsize</code></strong> :&ensp;<code>float</code> or <code>None</code>, optional</dt>
<dd>size (in data units matching the original scale bar, e.g. nm) of
the scale bar to use. The default <code>None</code>, wich takes the desired
length for the current scale (ca. 15% of the width of the image for
<code>scale=1</code>) and round this to the nearest option from a list of
"nice" values.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>factor to change the size of the scalebar+text with respect to the
width of the image. Scale is chosen such, that at <code>scale=1</code> the
font size of the scale bar text is approximately 10 pt when
the image is printed at half the width of the text in a typical A4
paper document (e.g. two images side-by-side). Note that this is
with respect to the <strong>output</strong> image, so after optional cropping
and/or up/down sampling has been applied. The default is <code>1</code>.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>int, one</code> of <code>[</code>0<code>,</code>1<code>,</code>2<code>,</code>3<code>]</code>, optional</dt>
<dd>Location of the scalebar on the image, where <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code>
refer to the top left, top right, bottom left and bottom right
respectively. The default is <code>2</code>, which is the bottom left corner.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>str, one</code> of <code>[</code>'fm'<code>,</code>'pm'<code>,</code>'Å'<code> or </code>A<code>,</code>'nm'<code>,</code>'µm'<code> or </code>'um'<code>,</code>'mm'<code>,</code>'cm'<code>,</code>'dm'<code>,</code>'m'<code>]</code>, optional</dt>
<dd>Unit that will be used for the scale bar, the value will be
automatically converted if this unit differs from the pixel size
unit. The default is <code>None</code>, which uses micrometers.</dd>
<dt><strong><code>barcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the scalebar and text, given as a tuple of
form (R,G,B) or (R,G,B,A) where R, G B and A are values between 0
and 255 for red, green, blue and alpha respectively. The default is
<code>(255,255,255)</code>, which gives a white scalebar.</dd>
<dt><strong><code>barthickness</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>thickness in printer points of the scale bar itself. The default is
16.</dd>
<dt><strong><code>barpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size in printer points of the padding between the scale bar and the
surrounding box. The default is 10.</dd>
<dt><strong><code>draw_text</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to draw the text specified in <code>text</code> on the image, the text
is place above the scale bar if <code>draw_bar=True</code>. The default is
<code>True</code>.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the text to draw on the image (above the scale bar if
<code>draw_bar=True</code>). The default is <code>None</code>, which gives the size and
unit of the scale bar (e.g. <code>'10 µm'</code>).</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>filename of an installed TrueType font ('.ttf' file) to use for the
text on the scalebar. The default is <code>'arialbd.ttf'</code>.</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>base font size to use for the scale bar text. The default is 16.
Note that this size will be re-scaled according to <code>resolution</code> and
<code>scale</code>.</dd>
<dt><strong><code>fontcolor</code></strong> :&ensp;<code>tuple</code> of <code>int</code>, optional</dt>
<dd>(R,G,B) tuple where R, G and B are red, green and blue values from
0 to 255. The default is (255,255,255) giving white text.</dd>
<dt><strong><code>fontbaseline</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>vertical offset for the baseline of the scale bar text in from the
top of the scale bar in printer points. The default is 10.</dd>
<dt><strong><code>fontpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>minimum size in printer points of the space/padding between the
text and surrounding box. The default is 10.</dd>
<dt><strong><code>draw_box</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to put a colored box behind the scalebar and text to
enhance contrast on busy images. The default is <code>False</code>.</dd>
<dt><strong><code>boxcolor</code></strong> :&ensp;<code>tuple</code> of <code>ints</code>, optional</dt>
<dd>RGB color to use for the box behind/around the scalebar and text,
given as a tuple of form (R,G,B) or (R,G,B,A) where R, G B and A
are values between 0 and 255 for red, green and blue respectively.
If no A is given, <code>boxopacity</code> is used. The default is (0,0,0)
which gives a black box.</dd>
<dt><strong><code>boxopacity</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>value between 0 and 255 for the opacity/alpha of the box, useful
for creating a semitransparent box. The default is 255.</dd>
<dt><strong><code>boxpad</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>size of the space/padding around the box (with respect to the sides
of the image) in printer points. The default is 10.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to save the image as file. The default is True.</dd>
<dt><strong><code>show_figure</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to open matplotlib figure windows. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Y×X×4 numpy.array containing the BGRA pixel data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_dimension_steps"><code class="name flex">
<span>def <span class="ident">get_dimension_steps</span></span>(<span>self, dim, use_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>return a list of physical values along a certain dimension, e.g.
the x-coordinates or timesteps.</p></div>
</dd>
<dt id="scm_confocal.visitech_series.get_image_metadata"><code class="name flex">
<span>def <span class="ident">get_image_metadata</span></span>(<span>self, indices=slice(None, None, None))</span>
</code></dt>
<dd>
<div class="desc"><p>loads the part of the metadata containing information about the time,
position etc. for each frame of the series and returns a dataframe
indexes by image frame</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code>, optional</dt>
<dd>which image frames to load the metadata for. The default is all
frames.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>imagedata</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>the metadata for the images, indexed by frame number.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns xml tree
object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree</code></dt>
<dd>formatted XML metadata. Can be indexed with
xml_root.find('<element name>')</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_metadata_dimensions"><code class="name flex">
<span>def <span class="ident">get_metadata_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>finds the stack's dimensionality and logical shape based on the
embedded metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code> of <code>ints</code></dt>
<dd>logical sizes of the stack</dd>
<dt><strong><code>dimorder</code></strong> :&ensp;<code>tuple</code> of <code>strings</code></dt>
<dd>order of the dimensions corresponding to the shape</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut to get <code>(z,y,x)</code> pixelsize with unit</p></div>
</dd>
<dt id="scm_confocal.visitech_series.get_series_name"><code class="name flex">
<span>def <span class="ident">get_series_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a name for the series based on the filename.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, indices=slice(None, None, None), dtype=numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>load images from datafile into 3D numpy array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code> or <code>list</code> of <code>ints</code>, optional</dt>
<dd>which images from tiffstack to load. The default is
slice(None,None,None).</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np int datatype</code></dt>
<dd>data type / bit depth to rescale data to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray containing image data in dim order (im,y,x)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data and reshape into 4D stack with the following dimension
order: ('channel','time','z-axis','y-axis','x-axis') where dimensions
with len 1 are omitted.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:
dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
The default is {} which corresponds to the full file.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.yield_stack"><code class="name flex">
<span>def <span class="ident">yield_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy-load the data and reshape into 4D stack with the following
dimension order: ('time','z-axis','y-axis','x-axis'). Returns a
generator which yields a z-stack for each call, which is loaded upon
calling it.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.
The shape of the stack can be accessed without loading data using the
stack_shape attribute after creating the yield_stack object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zstack</code></strong> :&ensp;<code>iterable/generator yielding numpy.ndarray</code></dt>
<dd>list of time steps, with for each time step a z-stack as np.ndarray
with the pixel values</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scm_confocal.util" href="util.html">scm_confocal.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scm_confocal.sp8_image" href="#scm_confocal.sp8_image">sp8_image</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.sp8_image.export_with_scalebar" href="#scm_confocal.sp8_image.export_with_scalebar">export_with_scalebar</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_channel" href="#scm_confocal.sp8_image.get_channel">get_channel</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_channels" href="#scm_confocal.sp8_image.get_channels">get_channels</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_detector_settings" href="#scm_confocal.sp8_image.get_detector_settings">get_detector_settings</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_dimension" href="#scm_confocal.sp8_image.get_dimension">get_dimension</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_dimension_steps" href="#scm_confocal.sp8_image.get_dimension_steps">get_dimension_steps</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_dimension_stepsize" href="#scm_confocal.sp8_image.get_dimension_stepsize">get_dimension_stepsize</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_dimensions" href="#scm_confocal.sp8_image.get_dimensions">get_dimensions</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_laser_settings" href="#scm_confocal.sp8_image.get_laser_settings">get_laser_settings</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_name" href="#scm_confocal.sp8_image.get_name">get_name</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_pixelsize" href="#scm_confocal.sp8_image.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.sp8_image.get_stage_position" href="#scm_confocal.sp8_image.get_stage_position">get_stage_position</a></code></li>
<li><code><a title="scm_confocal.sp8_image.load_frame" href="#scm_confocal.sp8_image.load_frame">load_frame</a></code></li>
<li><code><a title="scm_confocal.sp8_image.load_plane" href="#scm_confocal.sp8_image.load_plane">load_plane</a></code></li>
<li><code><a title="scm_confocal.sp8_image.load_stack" href="#scm_confocal.sp8_image.load_stack">load_stack</a></code></li>
<li><code><a title="scm_confocal.sp8_image.print_metadata" href="#scm_confocal.sp8_image.print_metadata">print_metadata</a></code></li>
<li><code><a title="scm_confocal.sp8_image.save_metadata" href="#scm_confocal.sp8_image.save_metadata">save_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.sp8_lif" href="#scm_confocal.sp8_lif">sp8_lif</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.sp8_lif.get_image" href="#scm_confocal.sp8_lif.get_image">get_image</a></code></li>
<li><code><a title="scm_confocal.sp8_lif.get_liffile_image" href="#scm_confocal.sp8_lif.get_liffile_image">get_liffile_image</a></code></li>
<li><code><a title="scm_confocal.sp8_lif.get_name" href="#scm_confocal.sp8_lif.get_name">get_name</a></code></li>
<li><code><a title="scm_confocal.sp8_lif.save_metadata" href="#scm_confocal.sp8_lif.save_metadata">save_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.sp8_series" href="#scm_confocal.sp8_series">sp8_series</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.sp8_series.export_with_scalebar" href="#scm_confocal.sp8_series.export_with_scalebar">export_with_scalebar</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_dimension_steps" href="#scm_confocal.sp8_series.get_dimension_steps">get_dimension_steps</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_dimension_stepsize" href="#scm_confocal.sp8_series.get_dimension_stepsize">get_dimension_stepsize</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_laser_settings" href="#scm_confocal.sp8_series.get_laser_settings">get_laser_settings</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_channels" href="#scm_confocal.sp8_series.get_metadata_channels">get_metadata_channels</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_dimension" href="#scm_confocal.sp8_series.get_metadata_dimension">get_metadata_dimension</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_dimensions" href="#scm_confocal.sp8_series.get_metadata_dimensions">get_metadata_dimensions</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_name" href="#scm_confocal.sp8_series.get_name">get_name</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_pixelsize" href="#scm_confocal.sp8_series.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_series_name" href="#scm_confocal.sp8_series.get_series_name">get_series_name</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_data" href="#scm_confocal.sp8_series.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_metadata" href="#scm_confocal.sp8_series.load_metadata">load_metadata</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_stack" href="#scm_confocal.sp8_series.load_stack">load_stack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.visitech_faststack" href="#scm_confocal.visitech_faststack">visitech_faststack</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.visitech_faststack.export_with_scalebar" href="#scm_confocal.visitech_faststack.export_with_scalebar">export_with_scalebar</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_metadata" href="#scm_confocal.visitech_faststack.get_metadata">get_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_pixelsize" href="#scm_confocal.visitech_faststack.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_series_name" href="#scm_confocal.visitech_faststack.get_series_name">get_series_name</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_timestamps" href="#scm_confocal.visitech_faststack.get_timestamps">get_timestamps</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.load_data" href="#scm_confocal.visitech_faststack.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.load_stack" href="#scm_confocal.visitech_faststack.load_stack">load_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.save_stack" href="#scm_confocal.visitech_faststack.save_stack">save_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.yield_stack" href="#scm_confocal.visitech_faststack.yield_stack">yield_stack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.visitech_series" href="#scm_confocal.visitech_series">visitech_series</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.visitech_series.export_with_scalebar" href="#scm_confocal.visitech_series.export_with_scalebar">export_with_scalebar</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_dimension_steps" href="#scm_confocal.visitech_series.get_dimension_steps">get_dimension_steps</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_image_metadata" href="#scm_confocal.visitech_series.get_image_metadata">get_image_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_metadata" href="#scm_confocal.visitech_series.get_metadata">get_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_metadata_dimensions" href="#scm_confocal.visitech_series.get_metadata_dimensions">get_metadata_dimensions</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_pixelsize" href="#scm_confocal.visitech_series.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_series_name" href="#scm_confocal.visitech_series.get_series_name">get_series_name</a></code></li>
<li><code><a title="scm_confocal.visitech_series.load_data" href="#scm_confocal.visitech_series.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.visitech_series.load_stack" href="#scm_confocal.visitech_series.load_stack">load_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_series.yield_stack" href="#scm_confocal.visitech_series.yield_stack">yield_stack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>