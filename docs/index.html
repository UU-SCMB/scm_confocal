<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scm_confocal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>scm_confocal</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scm_confocal.sp8" href="sp8.html">scm_confocal.sp8</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="scm_confocal.visitech" href="visitech.html">scm_confocal.visitech</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scm_confocal.sp8_series"><code class="flex name class">
<span>class <span class="ident">sp8_series</span></span>
<span>(</span><span>fmt='*.tif')</span>
</code></dt>
<dd>
<div class="desc"><p>Class of functions related to the sp8 microscope. The functions assume that
the data are exported as .tif files and placed in a own folder per series.
The current working directory is assumed to be that folder. For several
functions it is required that the xml metadata is present in a subfolder of
the working directory called 'MetaData', which is normally generated
automatically when exporting tif files as raw data.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>the filenames loaded associated with the series</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>the image data as loaded on the most recent call of sp8_series.load_data()</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>xml.Elementtree root</code></dt>
<dd>the recording parameters associated with the image series</dd>
</dl>
<p>Initialize the class instance and assign the filenames of the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>format to use for finding the files. Uses the notation of the glob
library. The default is '*.tif'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.sp8_series.get_dimension_steps"><code class="name flex">
<span>def <span class="ident">get_dimension_steps</span></span>(<span>self, dim, load_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of values for each step along the specified dimension, e.g.
a list of timestamps for the images or a list of height values for all
slices of a z-stack. For specification of dimensions, see
sp8_series.get_metadata_dimension()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get steps for</dd>
<dt><strong><code>load_stack_indices</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, trims down the list of steps based on the dim_range used
when last loading data with load_stack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>list</code></dt>
<dd>list of values for every logical step in the data</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code></dt>
<dd>physical unit of the step values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_dimension_stepsize"><code class="name flex">
<span>def <span class="ident">get_dimension_stepsize</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of a single step along the specified dimension, e.g.
the pixelsize in x, y or z, or the time between timesteps. For
specification of dimensions, see sp8_series.get_metadata_dimension()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get stepsize for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>stepsize</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>int</code></dt>
<dd>physical unit of value</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_channels"><code class="name flex">
<span>def <span class="ident">get_metadata_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the channel information from the metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>channels</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>list of dictionaries with length equal to number of channels where
each dict contains the metadata for one channel</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_dimension"><code class="name flex">
<span>def <span class="ident">get_metadata_dimension</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the dimension data for a particular dimension. Dimension can be
given both as integer index (as specified by the Leica exported
MetaData which may not correspond to the indexing order of the data
stack) or as string containing the physical meaning, e.g. 'x-axis',
'time', 'excitation wavelength', etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>dimension to get metadata of specified as integer or as name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary containing all metadata for that dimension</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_metadata_dimensions"><code class="name flex">
<span>def <span class="ident">get_metadata_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the dimension information from the metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>list of dictionaries with length number of dimensions where
each dict contains the metadata for one data dimension</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.get_series_name"><code class="name flex">
<span>def <span class="ident">get_series_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string containing the filename (sans file extension) under
which the series is saved.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the series</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, filenames=None, first=None, last=None, dtype=numpy.uint8)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the sequence of images into ndarray of form (files,y,x) and
converts the data to dtype</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>filenames of images to load. The default is what is passed from
<strong>init</strong>, which by default is all .tif images in the current
working directory.</dd>
<dt><strong><code>first</code></strong> :&ensp;<code>None</code> or <code>int</code>, optional</dt>
<dd>index of first image to load. The default is None.</dd>
<dt><strong><code>last</code></strong> :&ensp;<code>None</code> or <code>int</code>, optional</dt>
<dd>index of last image to load plus one. The default is None.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>3d numpy array with dimension order (filenames,y,x).</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.load_metadata"><code class="name flex">
<span>def <span class="ident">load_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the xml metadata exported with the files as xml_root object which
can be indexed with xml.etree.ElementTree</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>xml.etree.ElementTree object</code></dt>
<dd>Parsable xml tree object containing all the metadata</dd>
</dl></div>
</dd>
<dt id="scm_confocal.sp8_series.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint8)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to sp8_series.load_data(), but converts the 3D array of images
automatically to a np.ndarray of the appropriate dimensionality.</p>
<p>Array dimensions are specified as follows:</p>
<pre><code>- If the number of detector channels is 2 or higher, the first
  array axis is the detector channel index (named 'channel').

- If the number of channels is 1, the first array axis is the first
  available dimension (instead of 'channel').

- Each subsequent array axis corresponds to a dimension as
  specified by and in reversed order of the metadata exported by
  the microscope software, excluding dimensions which are not
  available. The default order of dimensions in the metadata is:

     - (0 = 'channel')
     -  1 = 'x-axis'
     -  2 = 'y-axis'
     -  3 = 'z-axis'
     -  4 = 'time'
     -  5 = 'detection wavelength'
     -  6 = 'excitation wavelength'

- As an example, a 2 channel xyt measurement would result in a 4-d
  array with axis order ('channel','time','y-axis',
  'x-axis'), and a single channel xyz scan would be returned as
  ('z-axis','y-axis','x-axis')
</code></pre>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading one
channel of multichannel data or a particular z-range. An example
use for only taking time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {}.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
<dt><strong><code>dimorder</code></strong> :&ensp;<code>tuple</code></dt>
<dd>tuple with lenght data.ndim specifying the ordering of dimensions
in the data with labels from the metadata of the microscope.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.util"><code class="flex name class">
<span>class <span class="ident">util</span></span>
</code></dt>
<dd>
<div class="desc"><p>Set of utility functions for dealing with stacks and confocal data</p></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.util.average_nearest_neighbour_distance"><code class="name flex">
<span>def <span class="ident">average_nearest_neighbour_distance</span></span>(<span>features, pos_cols=['x (um)', 'y (um)', 'z (um)'])</span>
</code></dt>
<dd>
<div class="desc"><p>finds average distance of nearest neighbours from pandas array of
coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>dataframe containing the particle coordinates</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>list</code> of <code>strings</code>, optional</dt>
<dd>Names of columns to use for coordinates. The default is
['x (um)','y (um)','z (um)'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>average distance to the closest particle for all the pairs in the
set</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.bin_stack"><code class="name flex">
<span>def <span class="ident">bin_stack</span></span>(<span>images, n=1, blocksize=None, quiet=False, dtype=numpy.uint8)</span>
</code></dt>
<dd>
<div class="desc"><p>bins numpy ndarrays in arbitrary dimensions by a factor n. Prior to
binning, elements from the end are deleted until the length is a
multiple of the bin factor. Executes averaging of bins in floating
point precision, which is memory intensive for large stacks. Using
smaller blocks reduces memory usage, but is less efficient.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray containing the data</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code> or <code>tuple</code> of <code>int</code>, optional</dt>
<dd>factor to bin with for all dimensions (int) or each dimension
individually (tuple with one int per dimension). The default is 1.</dd>
<dt><strong><code>blocksize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of (binned) slices to process at a time to conserve memory.
The default is entire stack.</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>suppresses printed output when True. The default is False.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>datatype to use for output. Averaging of the binned pixels always
occurs in floating point precision. The default is np.uint8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>binned stack</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.fit_powerlaw"><code class="name flex">
<span>def <span class="ident">fit_powerlaw</span></span>(<span>x, y, weights=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear regression in log space of the MSD to get diffusion constant, which
is a powerlaw in linear space of the form A<em>x</em>*n</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>list</code> or <code>numpy.array</code></dt>
<dd>x coordinates of data points to fit</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code> or <code>numpy.array</code></dt>
<dd>y coordinates of data points to fit</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>list</code> or <code>numpy.array</code>, optional</dt>
<dd>list of weights to use for each (x,y) coordinate. The default is
None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>float</code></dt>
<dd>constant A</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>float</code></dt>
<dd>power n</dd>
<dt><strong><code>sigmaA</code></strong> :&ensp;<code>float</code></dt>
<dd>standard deviation in A</dd>
<dt><strong><code>sigmaN</code></strong> :&ensp;<code>float</code></dt>
<dd>standard deviation in n</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.flatfield_correction_apply"><code class="name flex">
<span>def <span class="ident">flatfield_correction_apply</span></span>(<span>images, corrim, dtype=None, check_overflow=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a correction to all images in a dataset based on a mask /
correction image such as provided by util.flatfield_correction_init.
Pixel values are divided by the correction image, accounting for
integer overflow by clipping to the max value of the (integer) dtype.</p>
<p>Note that overflow checking is currently implemented using numpy masked
arrays, which are extremely slow (up to 10x) when compared to normal
numpy arrays. It can be bypassed using check_overflow for a memory and
performance improvement.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>(sequence of) numpy.array</code></dt>
<dd>the images to correct. he last two dimensions are taken as the 2D
images, other dimensions are preserved. Must have 2 or more dims.</dd>
<dt><strong><code>corrim</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>The correction image to apply. Must have 2 or more dimensions, if
there are more than 2 it must match <code>images</code> according to numpy
broadcasting rules.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>data type</code>, optional</dt>
<dd>data type used for the output. The default is images.dtype.</dd>
<dt><strong><code>check_overflow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to check and avoid integer overflow. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.array</code></dt>
<dd>the corrected image array</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="scm_confocal.util.flatfield_correction_init" href="#scm_confocal.util.flatfield_correction_init">util.flatfield_correction_init()</a></code></p></div>
</dd>
<dt id="scm_confocal.util.flatfield_correction_init"><code class="name flex">
<span>def <span class="ident">flatfield_correction_init</span></span>(<span>images, kernelsize, average=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a correction image for inhomogeneous illumination based on low
frequency fourier components. Particularly useful for data from the
Visitech recorded at relatively large frame size / low imaging rate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>(sequence of) numpy array with &gt;= 2 dimensions</code></dt>
<dd>image(s) to calculate a correction image for. The last two
dimensions are taken as the 2D images.</dd>
<dt><strong><code>kernelsize</code></strong> :&ensp;<code>int</code></dt>
<dd>cutoff size in fourier-space pixels (i.e. cycles per image-size) of
cone-shaped low-pass fourier filter.</dd>
<dt><strong><code>average</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to average correction images along the first dimension of
the supplied data. Requires &gt;2 dimensions in the input data. The
default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>(array of) normalized correction images where the maximum is scaled
to 1.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="scm_confocal.util.flatfield_correction_apply" href="#scm_confocal.util.flatfield_correction_apply">util.flatfield_correction_apply()</a></code></p></div>
</dd>
<dt id="scm_confocal.util.mean_square_displacement"><code class="name flex">
<span>def <span class="ident">mean_square_displacement</span></span>(<span>features, pos_cols=['x', 'y', 'z'], t_col='t (s)', nparticles=None, pickrandom=False, nbins=20, tmin=None, tmax=None, parallel=False, cores=None)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate the mean square displacement vs time for linked particles</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>output from trackpy.link containing tracking data</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>names of columns to use for coordinates. The default is
['x','y','z'].</dd>
<dt><strong><code>t_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name of column containing timestamps. The default is 't (s)'.</dd>
<dt><strong><code>nparticles</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of particles to use for calculation (useful for large
datasets). The default is all particles.</dd>
<dt><strong><code>pickrandom</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to pick nparticles randomly or not, if False it takes the
n longest tracked particles from data. The default is False.</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of bins for output. The default is 20.</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>left edge of first bin. The default is min(t_col).</dd>
<dt><strong><code>tmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>&nbsp;</dd>
<dt>right edge of last bin, The default is max(t_col).</dt>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to use the parallelized implementation. Requires rest of
the code to be protected in a if <strong>name</strong> == '<strong>main</strong>' block. The
default is False.</dd>
<dt><strong><code>cores</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the number of cores to use when using the parallelized
implementation. When parallel=False this option is ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>binedges</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>edges of time bins</dd>
<dt><strong><code>bincounts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>number of sampling points for each bin</dd>
<dt><strong><code>binmeans</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>mean square displacement values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.mean_square_displacement_per_frame"><code class="name flex">
<span>def <span class="ident">mean_square_displacement_per_frame</span></span>(<span>features, pos_cols=['x', 'y'], feat_col='particle')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the mean square movement of all tracked features between
subsequent frames using efficient pandas linear algebra</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>pandas.Dataframe</code></dt>
<dd>dataframe containing the tracking data over timesteps indexed by
frame number and containing coordinates of features.</dd>
<dt><strong><code>pos_cols</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>names of the columns containing coordinates. The default is
['x','y'].</dd>
<dt><strong><code>feat_col</code></strong> :&ensp;<code>str</code></dt>
<dd>name of column containing feature identifyers. The default is
'particle'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>msd</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>averages of the squared displacements between each two steps</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.multiply_intensity"><code class="name flex">
<span>def <span class="ident">multiply_intensity</span></span>(<span>data, factor, dtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>For multiplying the values of a numpy array while accounting for
integer overflow issues in integer datatypes. Corrected values larger
than the datatype max are set to the max value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>array containing the data values</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>factor to multiply data with</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>Datatype to scale data to. The default is the same type as the
input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>data with new intensity values.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.pair_correlation_2d"><code class="name flex">
<span>def <span class="ident">pair_correlation_2d</span></span>(<span>features, rmin=0, rmax=10, dr=None, ndensity=None, boundary=None, column_headers=['y', 'x'], periodic_boundary=False, handle_edge=True)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 2D coordinate sets. Edge correction is fully analytic.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>pandas DataFrame</code> or <code>numpy.ndarray</code></dt>
<dd>contains coordinates in (y,x)</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is
(rmax-rmin)/20.</dd>
<dt><strong><code>ndensity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>number density of particles in sample. The default is None which
computes the number density from the input data.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>positions of the walls that define the bounding box of the
coordinates, given as
<code>(ymin,ymax,xmin,xmax)</code>. The
default is the min and max values in the dataset along each
dimension.</dd>
<dt><strong><code>column_headers</code></strong> :&ensp;<code>list</code> of <code>string</code>, optional</dt>
<dd>column labels which contain the coordinates to use in case features
is given as a pandas.DataFrame. The default is [y','x'].</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is
False.</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to correct for edge effects in non-periodic boundary
conditions. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>edges of the bins in r</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>normalized count values in each bin of the g(r)</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.pair_correlation_3d"><code class="name flex">
<span>def <span class="ident">pair_correlation_3d</span></span>(<span>features, rmin=0, rmax=10, dr=None, ndensity=None, boundary=None, column_headers=['z', 'y', 'x'], periodic_boundary=False, handle_edge=True)</span>
</code></dt>
<dd>
<div class="desc"><p>calculates g(r) via a 'conventional' distance histogram method for a
set of 3D coordinate sets. Edge correction is fully analytic and based
on refs [1] and [2].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>pandas DataFrame</code> or <code>numpy.ndarray</code></dt>
<dd>contains coordinates in (z,y,x)</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>lower bound for the pairwise distance, left edge of 0th bin. The
default is 0.</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>upper bound for the pairwise distance, right edge of last bin. The
default is 10.</dd>
<dt><strong><code>dr</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>bin width for the pairwise distance bins. The default is
(rmax-rmin)/20.</dd>
<dt><strong><code>ndensity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>number density of particles in sample. The default is None which
computes the number density from the input data.</dd>
<dt><strong><code>boundary</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>positions of the walls that define the bounding box of the
coordinates, given as
<code>(zmin,zmax,ymin,ymax,xmin,xmax)</code>. The
default is the min and max values in the dataset along each
dimension.</dd>
<dt><strong><code>column_headers</code></strong> :&ensp;<code>list</code> of <code>string</code>, optional</dt>
<dd>column labels which contain the coordinates to use in case features
is given as a pandas.DataFrame. The default is ['z','y','x'].</dd>
<dt><strong><code>periodic_boundary</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether periodic boundary conditions are used. The default is
False.</dd>
<dt><strong><code>handle_edge</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to correct for edge effects in non-periodic boundary
conditions. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>edges of the bins in r</dd>
<dt><strong><code>counts</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>normalized count values in each bin of the g(r)</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Markus Seserno (2014). How to calculate a three-dimensional g(r)
under periodic boundary conditions.
<a href="https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf">https://www.cmu.edu/biolphys/deserno/pdf/gr_periodic.pdf</a></p>
<p>[2] Kopera, B. A. F., &amp; Retsch, M. (2018). Computing the 3D Radial
Distribution Function from Particle Positions: An Advanced Analytic
Approach. Analytical Chemistry, 90(23), 13909â€“13914.
<a href="https://doi.org/10.1021/acs.analchem.8b03157">https://doi.org/10.1021/acs.analchem.8b03157</a></p></div>
</dd>
<dt id="scm_confocal.util.plot_stack_histogram"><code class="name flex">
<span>def <span class="ident">plot_stack_histogram</span></span>(<span>images, bin_edges=range(0, 256), newfig=True, legendname=None, title='intensity histogram')</span>
</code></dt>
<dd>
<div class="desc"><p>manually flattens list of images to list of pixel values and plots
histogram. Can combine multiple calls with newfig and legendname
options</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>numpy ndarray</code></dt>
<dd>array containing pixel values</dd>
<dt><strong><code>bin_edges</code></strong> :&ensp;<code>list</code> or <code>range</code>, optional</dt>
<dd>edges of bins to use. The default is range(0,256).</dd>
<dt><strong><code>newfig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to open a new figure or to add to currently active figure.
The default is True.</dd>
<dt><strong><code>legendname</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>label to use for the legend. The default is None.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>text to use as plot title. The default is 'intensity histogram'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pyplot figure handle</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.saveprompt"><code class="name flex">
<span>def <span class="ident">saveprompt</span></span>(<span>question='Save/overwrite? 1=YES, 0=NO. ')</span>
</code></dt>
<dd>
<div class="desc"><p>Asks user a question (whether to save). If 1 is entered, it returns
True, for any other answer it returns False</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>question</code></strong> :&ensp;<code>string</code></dt>
<dd>The question to prompt the user for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to save</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.subtract_background"><code class="name flex">
<span>def <span class="ident">subtract_background</span></span>(<span>images, val=0, percentile=False)</span>
</code></dt>
<dd>
<div class="desc"><p>subtract a constant value from a numpy array without going below 0</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>numpy ndarray</code></dt>
<dd>images to correct.</dd>
<dt><strong><code>percentile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to give the value as a percentile of the stack rather than
an absolute value to subtrackt. The default is False.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Value or percentile to subtract. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>numpy ndarray</code></dt>
<dd>the corrected stack.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.util.write_textfile"><code class="name flex">
<span>def <span class="ident">write_textfile</span></span>(<span>params, filename='parameters.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>stores parameter names and values in text file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dictionary</code> of <code>name:value</code></dt>
<dd>the data to store</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>file name to us for saving. The default is "parameters.txt".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.visitech_faststack"><code class="flex name class">
<span>class <span class="ident">visitech_faststack</span></span>
<span>(</span><span>filename, zsize, zstep, zbacksteps, zstart=0, magnification=63, binning=1)</span>
</code></dt>
<dd>
<div class="desc"><p>functions for fast stacks taken with the custom MicroManager Visitech
driver, saved to multipage .ome.tiff files containing entire stack</p>
<p>initialize class (lazy-loads data)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>string</code></dt>
<dd>name of first ome.tiff file (extension optional)</dd>
<dt><strong><code>zsize</code></strong> :&ensp;<code>float</code></dt>
<dd>z size (in um) of stack (first im to last)</dd>
<dt><strong><code>zstep</code></strong> :&ensp;<code>float</code></dt>
<dd>step size in z</dd>
<dt><strong><code>zbacksteps</code></strong> :&ensp;<code>int</code></dt>
<dd>number of backwards steps in z direction after each stack</dd>
<dt><strong><code>zstart</code></strong> :&ensp;<code>float</code></dt>
<dd>actual height of bottom of stack/lowest slice. The default is 0.</dd>
<dt><strong><code>magnification</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>magnification of objective lens used. The default is 63.</dd>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code></dt>
<dd>binning factor performed at the detector level, e.g. in
MicroManager software, in XY</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.visitech_faststack.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self, read_from_end=True)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns xml tree object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>read_from_end</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to look for the metadata from the end of the file.
The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree</code></dt>
<dd>formatted XML metadata. Can be indexed with
xml_root.find('<element name>')</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut to get (z,y,x) pixelsize with unit</p></div>
</dd>
<dt id="scm_confocal.visitech_faststack.get_timestamps"><code class="name flex">
<span>def <span class="ident">get_timestamps</span></span>(<span>self, load_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns timestamps</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>load_stack_indices</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True, only returns timestamps from frames which were loaded
at call to visitech_faststack.load_stack(), and using the same
dimension order / stack shape</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>numpy (nd)array</code> of <code>floats</code></dt>
<dd>list/stack of timestamps for each of the the frames in the data</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, indices=slice(None, None, None), dtype=numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>load images from datafile into 3D numpy array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code> or <code>list</code> of <code>ints</code>, optional</dt>
<dd>which images from tiffstack to load. The default is
slice(None,None,None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray containing image data in dim order (im,y,x)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True, offset=0, force_reshape=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data and reshape into 4D stack with the following dimension
order: ('time','z-axis','y-axis','x-axis')</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the <code>x</code> or <code>y</code> axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified <code>x</code> or <code>y</code> axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>offset the indices by a constant number of frames in case the first
im is not the first slice of the first stack</dd>
<dt><strong><code>force_reshape</code></strong> :&ensp;<code>bool</code></dt>
<dd>in case of incorrect number of steps during acquisition, you can
use this to ignore the reshape-error occuring upon trying to sort
2d images into 4d stack series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_faststack.save_stack"><code class="name flex">
<span>def <span class="ident">save_stack</span></span>(<span>self, data, filename_prefix='visitech_faststack', sequence_type='multipage')</span>
</code></dt>
<dd>
<div class="desc"><p>save stacks to tiff files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy ndarray with 3</code> or <code>4 dimensions</code></dt>
<dd>image series pixel values with dimension order (z,y,x) or (t,z,y,x)</dd>
<dt><strong><code>filename_prefix</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>prefix to use for filename. The time/z-axis index is appended if
relevant. The default is 'visitech_faststack'.</dd>
<dt><strong><code>sequence_type</code></strong> :&ensp;<code>{'multipage','image_sequence','multipage_sequence'}</code>, optional</dt>
<dd>
<p>The way to store the data. The following options are available:</p>
<pre><code>- 'image_sequence' : stores as a series of 2D images with time and or frame number appended
- 'multipage' : store all data in a single multipage tiff file
- 'multipage_sequence' : stores a multipage tiff file for each time step
</code></pre>
<p>The default is 'multipage'.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None, but writes file(s) to working directory.</p></div>
</dd>
<dt id="scm_confocal.visitech_faststack.yield_stack"><code class="name flex">
<span>def <span class="ident">yield_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True, offset=0, force_reshape=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy-load the data and reshape into 4D stack with the following
dimension order: ('time','z-axis','y-axis','x-axis'). Returns a
generator which yields a z-stack for each call, which is loaded upon
calling it.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.
The shape of the stack can be accessed without loading data using the
stack_shape attribute after creating the yield_stack object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>offset the indices by a constant number of frames in case the first
im is not the first slice of the first stack</dd>
<dt><strong><code>force_reshape</code></strong> :&ensp;<code>bool</code></dt>
<dd>in case of incorrect number of steps during acquisition, you can
use this to ignore the reshape-error occuring upon trying to sort
2d images into 4d stack series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zstack</code></strong> :&ensp;<code>iterable/generator yielding numpy.ndarray</code></dt>
<dd>list of time steps, with for each time step a z-stack as np.ndarray
with the pixel values</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="scm_confocal.visitech_series"><code class="flex name class">
<span>class <span class="ident">visitech_series</span></span>
<span>(</span><span>filename, magnification=63, binning=1)</span>
</code></dt>
<dd>
<div class="desc"><p>functions for image series taken with the multi-D acquisition menu in
MicroManager with the Visitech saved to multipage .ome.tiff files. For the
custom fast stack sequence use visitech_faststack.</p>
<p>initialize class (lazy-loads data)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>string</code></dt>
<dd>name of first ome.tiff file (extension optional)</dd>
<dt><strong><code>magnification</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>magnification of objective lens used. The default is 63.</dd>
<dt><strong><code>binning</code></strong> :&ensp;<code>int</code></dt>
<dd>binning factor performed at the detector level, e.g. in
MicroManager software, in XY</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scm_confocal.visitech_series.get_dimension_steps"><code class="name flex">
<span>def <span class="ident">get_dimension_steps</span></span>(<span>self, dim, use_stack_indices=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scm_confocal.visitech_series.get_image_metadata"><code class="name flex">
<span>def <span class="ident">get_image_metadata</span></span>(<span>self, indices=slice(None, None, None))</span>
</code></dt>
<dd>
<div class="desc"><p>loads the part of the metadata containing information about the time,
position etc. for each frame of the series and returns a dataframe
indexes by image frame</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code>, optional</dt>
<dd>which image frames to load the metadata for. The default is all
frames.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>imagedata</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>the metadata for the images, indexed by frame number.</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>self, read_from_end=True)</span>
</code></dt>
<dd>
<div class="desc"><p>loads OME metadata from visitech .ome.tif file and returns xml tree object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>read_from_end</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to look for the metadata from the end of the file.
The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree</code></dt>
<dd>formatted XML metadata. Can be indexed with
xml_root.find('<element name>')</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_metadata_dimensions"><code class="name flex">
<span>def <span class="ident">get_metadata_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>finds the stack's dimensionality and logical shape based on the
embedded metadata</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code> of <code>ints</code></dt>
<dd>logical sizes of the stack</dd>
<dt><strong><code>dimorder</code></strong> :&ensp;<code>tuple</code> of <code>strings</code></dt>
<dd>order of the dimensions corresponding to the shape</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shortcut to get <code>(z,y,x)</code> pixelsize with unit</p></div>
</dd>
<dt id="scm_confocal.visitech_series.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, indices=slice(None, None, None), dtype=numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>load images from datafile into 3D numpy array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>indices</code></strong> :&ensp;<code>slice object</code> or <code>list</code> of <code>ints</code>, optional</dt>
<dd>which images from tiffstack to load. The default is
slice(None,None,None).</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np int datatype</code></dt>
<dd>data type / bit depth to rescale data to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray containing image data in dim order (im,y,x)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.load_stack"><code class="name flex">
<span>def <span class="ident">load_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the data and reshape into 4D stack with the following dimension
order: ('channel','time','z-axis','y-axis','x-axis') where dimensions
with len 1 are omitted.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:
dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
The default is {} which corresponds to the full file.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>ndarray with the pixel values</dd>
</dl></div>
</dd>
<dt id="scm_confocal.visitech_series.yield_stack"><code class="name flex">
<span>def <span class="ident">yield_stack</span></span>(<span>self, dim_range={}, dtype=numpy.uint16, remove_backsteps=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Lazy-load the data and reshape into 4D stack with the following
dimension order: ('time','z-axis','y-axis','x-axis'). Returns a
generator which yields a z-stack for each call, which is loaded upon
calling it.</p>
<p>For loading only part of the total dataset, the dim_range parameter can
be used to specify a range along any of the dimensions. This will be
more memory efficient than loading the entire stack and then discarding
part of the data. For slicing along the x or y axis this is not
possible and whole (xy) images must be loaded prior to discarding
data outside the specified x or y axis range.
The shape of the stack can be accessed without loading data using the
stack_shape attribute after creating the yield_stack object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dim_range</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>dict, with keys corresponding to channel/dimension labels as above
and slice objects as values. This allows you to only load part of
the data along any of the dimensions, such as only loading two
time steps or a particular z-range. An example use for only taking
time steps up to 5 and z-slice 20 to 30 would
be:</p>
<pre><code>dim_range={'time':slice(None,5), 'z-axis':slice(20,30)}.
</code></pre>
<p>The default is {} which corresponds to the full file.</p>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>(numpy) datatype</code>, optional</dt>
<dd>type to scale data to. The default is np.uint16.</dd>
<dt><strong><code>remove_backsteps</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to discard the frames which were recorded on the backsteps
downwards</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zstack</code></strong> :&ensp;<code>iterable/generator yielding numpy.ndarray</code></dt>
<dd>list of time steps, with for each time step a z-stack as np.ndarray
with the pixel values</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scm_confocal.sp8" href="sp8.html">scm_confocal.sp8</a></code></li>
<li><code><a title="scm_confocal.visitech" href="visitech.html">scm_confocal.visitech</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scm_confocal.sp8_series" href="#scm_confocal.sp8_series">sp8_series</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.sp8_series.get_dimension_steps" href="#scm_confocal.sp8_series.get_dimension_steps">get_dimension_steps</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_dimension_stepsize" href="#scm_confocal.sp8_series.get_dimension_stepsize">get_dimension_stepsize</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_channels" href="#scm_confocal.sp8_series.get_metadata_channels">get_metadata_channels</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_dimension" href="#scm_confocal.sp8_series.get_metadata_dimension">get_metadata_dimension</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_metadata_dimensions" href="#scm_confocal.sp8_series.get_metadata_dimensions">get_metadata_dimensions</a></code></li>
<li><code><a title="scm_confocal.sp8_series.get_series_name" href="#scm_confocal.sp8_series.get_series_name">get_series_name</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_data" href="#scm_confocal.sp8_series.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_metadata" href="#scm_confocal.sp8_series.load_metadata">load_metadata</a></code></li>
<li><code><a title="scm_confocal.sp8_series.load_stack" href="#scm_confocal.sp8_series.load_stack">load_stack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.util" href="#scm_confocal.util">util</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.util.average_nearest_neighbour_distance" href="#scm_confocal.util.average_nearest_neighbour_distance">average_nearest_neighbour_distance</a></code></li>
<li><code><a title="scm_confocal.util.bin_stack" href="#scm_confocal.util.bin_stack">bin_stack</a></code></li>
<li><code><a title="scm_confocal.util.fit_powerlaw" href="#scm_confocal.util.fit_powerlaw">fit_powerlaw</a></code></li>
<li><code><a title="scm_confocal.util.flatfield_correction_apply" href="#scm_confocal.util.flatfield_correction_apply">flatfield_correction_apply</a></code></li>
<li><code><a title="scm_confocal.util.flatfield_correction_init" href="#scm_confocal.util.flatfield_correction_init">flatfield_correction_init</a></code></li>
<li><code><a title="scm_confocal.util.mean_square_displacement" href="#scm_confocal.util.mean_square_displacement">mean_square_displacement</a></code></li>
<li><code><a title="scm_confocal.util.mean_square_displacement_per_frame" href="#scm_confocal.util.mean_square_displacement_per_frame">mean_square_displacement_per_frame</a></code></li>
<li><code><a title="scm_confocal.util.multiply_intensity" href="#scm_confocal.util.multiply_intensity">multiply_intensity</a></code></li>
<li><code><a title="scm_confocal.util.pair_correlation_2d" href="#scm_confocal.util.pair_correlation_2d">pair_correlation_2d</a></code></li>
<li><code><a title="scm_confocal.util.pair_correlation_3d" href="#scm_confocal.util.pair_correlation_3d">pair_correlation_3d</a></code></li>
<li><code><a title="scm_confocal.util.plot_stack_histogram" href="#scm_confocal.util.plot_stack_histogram">plot_stack_histogram</a></code></li>
<li><code><a title="scm_confocal.util.saveprompt" href="#scm_confocal.util.saveprompt">saveprompt</a></code></li>
<li><code><a title="scm_confocal.util.subtract_background" href="#scm_confocal.util.subtract_background">subtract_background</a></code></li>
<li><code><a title="scm_confocal.util.write_textfile" href="#scm_confocal.util.write_textfile">write_textfile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.visitech_faststack" href="#scm_confocal.visitech_faststack">visitech_faststack</a></code></h4>
<ul class="two-column">
<li><code><a title="scm_confocal.visitech_faststack.get_metadata" href="#scm_confocal.visitech_faststack.get_metadata">get_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_pixelsize" href="#scm_confocal.visitech_faststack.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.get_timestamps" href="#scm_confocal.visitech_faststack.get_timestamps">get_timestamps</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.load_data" href="#scm_confocal.visitech_faststack.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.load_stack" href="#scm_confocal.visitech_faststack.load_stack">load_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.save_stack" href="#scm_confocal.visitech_faststack.save_stack">save_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_faststack.yield_stack" href="#scm_confocal.visitech_faststack.yield_stack">yield_stack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_confocal.visitech_series" href="#scm_confocal.visitech_series">visitech_series</a></code></h4>
<ul class="">
<li><code><a title="scm_confocal.visitech_series.get_dimension_steps" href="#scm_confocal.visitech_series.get_dimension_steps">get_dimension_steps</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_image_metadata" href="#scm_confocal.visitech_series.get_image_metadata">get_image_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_metadata" href="#scm_confocal.visitech_series.get_metadata">get_metadata</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_metadata_dimensions" href="#scm_confocal.visitech_series.get_metadata_dimensions">get_metadata_dimensions</a></code></li>
<li><code><a title="scm_confocal.visitech_series.get_pixelsize" href="#scm_confocal.visitech_series.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_confocal.visitech_series.load_data" href="#scm_confocal.visitech_series.load_data">load_data</a></code></li>
<li><code><a title="scm_confocal.visitech_series.load_stack" href="#scm_confocal.visitech_series.load_stack">load_stack</a></code></li>
<li><code><a title="scm_confocal.visitech_series.yield_stack" href="#scm_confocal.visitech_series.yield_stack">yield_stack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>